package utils

import (
	"crypto/ecdsa"
	"crypto/rsa"
	"crypto/x509"
	"strings"
	"time"

	"github.com/conectabase/sslscan/internal/models"
)

// VulnerabilityChecker provides centralized vulnerability checking
type VulnerabilityChecker struct{}

// NewVulnerabilityChecker creates a new vulnerability checker
func NewVulnerabilityChecker() *VulnerabilityChecker {
	return &VulnerabilityChecker{}
}

// CheckCertificateVulnerabilities checks for certificate vulnerabilities
func (vc *VulnerabilityChecker) CheckCertificateVulnerabilities(cert *x509.Certificate) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability

	// Check weak hash algorithms
	if strings.Contains(strings.ToUpper(cert.SignatureAlgorithm.String()), "MD5") {
		vuln := models.Vulnerability{
			Name:        "Weak Hash Algorithm",
			Severity:    models.VulnSeverityHigh,
			Description: "Certificate uses MD5 hash algorithm which is considered insecure",
			Details: map[string]interface{}{
				"algorithm": cert.SignatureAlgorithm.String(),
			},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	if strings.Contains(strings.ToUpper(cert.SignatureAlgorithm.String()), "SHA1") {
		vuln := models.Vulnerability{
			Name:        "Weak Hash Algorithm",
			Severity:    models.VulnSeverityMedium,
			Description: "Certificate uses SHA1 hash algorithm which is considered weak",
			Details: map[string]interface{}{
				"algorithm": cert.SignatureAlgorithm.String(),
			},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	// Check key size
	if cert.PublicKey != nil {
		switch pub := cert.PublicKey.(type) {
		case *rsa.PublicKey:
			if pub.N.BitLen() < 2048 {
				vuln := models.Vulnerability{
					Name:        "Weak Key Size",
					Severity:    models.VulnSeverityHigh,
					Description: "RSA key too small",
					Details: map[string]interface{}{
						"key_size":    pub.N.BitLen(),
						"recommended": 2048,
					},
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		case *ecdsa.PublicKey:
			if pub.Curve.Params().BitSize < 256 {
				vuln := models.Vulnerability{
					Name:        "Weak Key Size",
					Severity:    models.VulnSeverityHigh,
					Description: "ECDSA key too small",
					Details: map[string]interface{}{
						"key_size":    pub.Curve.Params().BitSize,
						"recommended": 256,
					},
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}

	// Check certificate expiration
	if time.Now().After(cert.NotAfter) {
		vuln := models.Vulnerability{
			Name:        "Expired Certificate",
			Severity:    models.VulnSeverityHigh,
			Description: "Certificate expired",
			Details: map[string]interface{}{
				"expiry_date": cert.NotAfter,
			},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	// Check certificate validity period
	validityPeriod := cert.NotAfter.Sub(cert.NotBefore)
	if validityPeriod > 365*24*time.Hour { // More than 1 year
		vuln := models.Vulnerability{
			Name:        "Long Validity Period",
			Severity:    models.VulnSeverityMedium,
			Description: "Certificate has a long validity period",
			Details: map[string]interface{}{
				"validity_days": int(validityPeriod.Hours() / 24),
				"recommended":   "365 days or less",
			},
		}
		vulnerabilities = append(vulnerabilities, vuln)
	}

	return vulnerabilities
}

// CreateVulnerability creates a vulnerability with common fields
func (vc *VulnerabilityChecker) CreateVulnerability(name, severity, description, cve string, details map[string]interface{}) models.Vulnerability {
	return models.Vulnerability{
		Name:        name,
		Severity:    severity,
		Description: description,
		CVE:         cve,
		Details:     details,
	}
}

// Global vulnerability checker instance
var GlobalVulnerabilityChecker = NewVulnerabilityChecker()
